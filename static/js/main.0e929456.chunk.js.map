{"version":3,"sources":["logo.svg","Card.tsx","SelectableCardList.tsx","Hand.tsx","Player.tsx","Players.tsx","CardList.tsx","Stack.tsx","Game.tsx","communication/serverApi.ts","serviceWorker.ts","index.tsx","App.tsx"],"names":["module","exports","JokerCard","card","kind","color","SuitCard","suit","rank","generateKey","JOKER_CARD_KIND","Card","CardList","cards","handleSelect","cardItems","map","key","type","checked","isSelected","onChange","PlayTurn","playSelectedCards","onClick","Hand","requestCards","playCards","useState","cardsInHand","setCardsInHand","isYourTurn","setIsYourTurn","useEffect","subscription","subscribe","unsubscribe","clicked","updatedCardsInHand","current","cardEquals","selectedCards","filter","otherCards","Player","playerId","Players","playerItems","Stack","playedCards","Game","serverApi","startGame","ofType","name","pipe","value","subject","next","MessageName","START_GAME","broadcastStartGame","BROADCAST_START_GAME","data","dealtCards","DEALT_CARDS","REQUEST_CARDS","PLAY_CARDS","broadcastPlayerTurn","BROADCAST_PLAYER_TURN","broadcastPlayerTurnError","BROADCAST_PLAYER_TURN_ERROR","broadcastStartRound","BROADCAST_START_ROUND","broadcastEndRound","BROADCAST_END_ROUND","broadcastStartCycle","BROADCAST_START_CYCLE","broadcastEndCycle","BROADCAST_END_CYCLE","broadcastStartPlayerTurn","BROADCAST_START_PLAYER_TURN","broadcastEndGame","BROADCAST_END_GAME","broadcastGameError","BROADCAST_GAME_ERROR","availableCards","AVAILABLE_CARDS","Boolean","window","location","hostname","match","ReactDOM","render","webSocket","complete","bind","createServerApi","className","src","logo","alt","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0e929456.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.25bf045c.svg\";","import React from 'react';\nimport {\n  Card as CardData, JOKER_CARD_KIND, JokerCard as JokerCardData, SuitCard as SuitCardData,\n} from 'agurk-shared';\n\ninterface CardProps {\n  card: CardData;\n}\n\ninterface JokerCardProps {\n  card: JokerCardData;\n}\n\ninterface SuitCardProps {\n  card: SuitCardData;\n}\n\nfunction JokerCard({ card }: JokerCardProps) {\n  return (\n    <div>\n      { card.kind }\n      { ' ' }\n      { card.color }\n    </div>\n  );\n}\n\nfunction SuitCard({ card }: SuitCardProps) {\n  return (\n    <div>\n      { card.suit }\n      {' '}\n      { card.rank }\n    </div>\n  );\n}\n\nexport function generateKey(card: CardData): string {\n  if (card.kind === JOKER_CARD_KIND) {\n    return card.color + card.rank;\n  }\n  return card.suit + card.rank;\n}\n\nexport default function Card({ card }: CardProps) {\n  return (\n    card.kind === JOKER_CARD_KIND\n      ? <JokerCard card={card} />\n      : <SuitCard card={card} />\n  );\n}\n","import React from 'react';\nimport { Card as CardData } from 'agurk-shared';\nimport Card, { generateKey } from './Card';\n\ninterface Selectable {\n  isSelected: boolean;\n}\n\nexport type SelectableCard = CardData & Selectable;\n\ninterface CardListProps {\n  cards: SelectableCard[];\n  handleSelect: (card: SelectableCard) => void;\n}\n\nexport default function CardList({ cards, handleSelect }: CardListProps) {\n  const cardItems = cards.map((card) => (\n    <li key={generateKey(card)}>\n      <input type=\"checkbox\" checked={card.isSelected} onChange={() => handleSelect(card)} />\n      <Card card={card} />\n    </li>\n  ));\n\n  return (\n    <ul>\n      { cardItems }\n    </ul>\n  );\n}\n","import React, { useEffect, useState } from 'react';\nimport { Observable } from 'rxjs';\nimport { Card, cardEquals } from 'agurk-shared';\nimport SelectableCardList, { SelectableCard } from './SelectableCardList';\n\ninterface HandProps {\n  requestCards: () => Observable<void>;\n  playCards: (cards: Card[]) => void;\n}\n\ninterface PlayTurnProps {\n  playSelectedCards: () => void;\n}\n\nfunction PlayTurn({ playSelectedCards }: PlayTurnProps) {\n  return (\n    <div>\n      <p><b>It is your turn...</b></p>\n      <button type=\"button\" onClick={playSelectedCards}>Play Cards</button>\n    </div>\n  );\n}\n\nexport default function Hand({ requestCards, playCards }: HandProps) {\n  const [cardsInHand, setCardsInHand] = useState<SelectableCard[]>([]);\n  const [isYourTurn, setIsYourTurn] = useState<boolean>(false);\n\n  function playSelectedCards() {\n    const selectedCards = cardsInHand.filter((card) => card.isSelected);\n    const otherCards = cardsInHand.filter((card) => !card.isSelected);\n    playCards(selectedCards);\n    setIsYourTurn(false);\n    setCardsInHand(otherCards);\n  }\n\n  function handleCardSelect(clicked: SelectableCard) {\n    const updatedCardsInHand = cardsInHand.map((current) => {\n      if (!cardEquals(clicked, current)) {\n        return current;\n      }\n      return {\n        ...current,\n        isSelected: !current.isSelected,\n      };\n    });\n\n    setCardsInHand(updatedCardsInHand);\n  }\n\n  useEffect(() => {\n    const subscription = requestCards().subscribe(() => setIsYourTurn(true));\n    return () => subscription.unsubscribe();\n  });\n\n  return (\n    <div>\n      <h2>Hand</h2>\n\n      <SelectableCardList cards={cardsInHand} handleSelect={handleCardSelect} />\n\n      { isYourTurn && <PlayTurn playSelectedCards={playSelectedCards} />}\n    </div>\n  );\n}\n","import React from 'react';\nimport { PlayerId } from 'agurk-shared';\n\ninterface PlayerProps {\n  playerId: PlayerId;\n}\n\nexport default function Player({ playerId }: PlayerProps) {\n  return (\n    <div>\n      <p>\n        { playerId }\n      </p>\n    </div>\n  );\n}\n","import React, { useState } from 'react';\nimport { PlayerId } from 'agurk-shared';\nimport Player from './Player';\n\nexport default function Players() {\n  const [playerIds] = useState<PlayerId[]>([]);\n  const playerItems = playerIds.map((playerId) => <li key={playerId}><Player playerId={playerId} /></li>);\n\n  return (\n    <div>\n      <h2>Players</h2>\n\n      <ul>\n        { playerItems }\n      </ul>\n    </div>\n  );\n}\n","import React from 'react';\nimport { Card as CardData } from 'agurk-shared';\nimport Card, { generateKey } from './Card';\n\ninterface CardListProps {\n  cards: CardData[];\n}\n\nexport default function CardList({ cards }: CardListProps) {\n  const cardItems = cards.map((card) => (\n    <li key={generateKey(card)}>\n      <Card card={card} />\n    </li>\n  ));\n\n  return (\n    <ul>\n      { cardItems }\n    </ul>\n  );\n}\n","import React, { useState } from 'react';\nimport { Card } from 'agurk-shared';\nimport CardList from './CardList';\n\nexport default function Stack() {\n  const [playedCards] = useState<Card[]>([]);\n\n  return (\n    <div>\n      <h2>Stack</h2>\n\n      <CardList cards={playedCards} />\n    </div>\n  );\n}\n","import React from 'react';\nimport Hand from './Hand';\nimport Players from './Players';\nimport Stack from './Stack';\nimport { ServerApi } from './communication/serverApi';\n\ninterface GameProps {\n  serverApi: ServerApi;\n}\n\nexport default function Game({ serverApi }: GameProps) {\n  return (\n    <div>\n      <h1>Agurk</h1>\n\n      <button type=\"button\" onClick={serverApi.startGame}>Start Game</button>\n\n      <Players />\n      <Stack />\n      <Hand\n        requestCards={serverApi.requestCards}\n        playCards={serverApi.playCards}\n      />\n    </div>\n  );\n}\n","import { Observable, pipe, UnaryFunction } from 'rxjs';\nimport {\n  AvailableCards,\n  BroadcastEndCycle,\n  BroadcastEndGame,\n  BroadcastEndRound,\n  BroadcastGameError,\n  BroadcastPlayerTurn,\n  BroadcastStartCycle,\n  BroadcastStartGame,\n  BroadcastStartPlayerTurn,\n  BroadcastStartRound,\n  Card,\n  DealtCards,\n  Error,\n  Message,\n  MessageName,\n  PlayerId,\n  RequestCards,\n  TurnError,\n  ValidatedTurn,\n  BroadcastPlayerTurnError,\n  StartRoundData,\n  EndRoundData,\n  EndCycleData,\n  EndGameData,\n  StartGameData, StartCycleData,\n} from 'agurk-shared';\nimport { filter, map } from 'rxjs/operators';\nimport { WebSocketSubject } from 'rxjs/webSocket';\n\nexport interface ServerApi {\n  startGame: () => void;\n  broadcastStartGame: () => Observable<StartGameData>;\n  dealtCards: () => Observable<Card[]>;\n  requestCards: () => Observable<void>;\n  playCards: (cards: Card[]) => void;\n  broadcastPlayerTurn: () => Observable<ValidatedTurn>;\n  broadcastPlayerTurnError: () => Observable<TurnError>;\n  broadcastStartRound: () => Observable<StartRoundData>;\n  broadcastEndRound: () => Observable<EndRoundData>;\n  broadcastStartCycle: () => Observable<StartCycleData>;\n  broadcastEndCycle: () => Observable<EndCycleData>;\n  broadcastStartPlayerTurn: () => Observable<PlayerId>;\n  broadcastEndGame: () => Observable<EndGameData>;\n  broadcastGameError: () => Observable<Error>;\n  availableCards: () => Observable<Card[]>;\n}\n\nfunction ofType<T extends Message>(name: MessageName): UnaryFunction<Observable<Message>, Observable<T>> {\n  return pipe(\n    filter((value: Message): value is T => value.name === name),\n  );\n}\n\nfunction startGame(subject: WebSocketSubject<Message>): void {\n  return subject.next({ name: MessageName.START_GAME });\n}\n\nfunction broadcastStartGame(subject: WebSocketSubject<Message>): Observable<StartGameData> {\n  return subject.pipe(\n    ofType<BroadcastStartGame>(MessageName.BROADCAST_START_GAME),\n    map((value) => value.data),\n  );\n}\n\nfunction dealtCards(subject: WebSocketSubject<Message>): Observable<Card[]> {\n  return subject.pipe(\n    ofType<DealtCards>(MessageName.DEALT_CARDS),\n    map((value) => value.data),\n  );\n}\n\nfunction requestCards(subject: WebSocketSubject<Message>): Observable<void> {\n  return subject.pipe(\n    ofType<RequestCards>(MessageName.REQUEST_CARDS),\n    map(() => undefined),\n  );\n}\n\nfunction playCards(subject: WebSocketSubject<Message>, cards: Card[]): void {\n  return subject.next({ name: MessageName.PLAY_CARDS, data: cards });\n}\n\nfunction broadcastPlayerTurn(subject: WebSocketSubject<Message>): Observable<ValidatedTurn> {\n  return subject.pipe(\n    ofType<BroadcastPlayerTurn>(MessageName.BROADCAST_PLAYER_TURN),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastPlayerTurnError(subject: WebSocketSubject<Message>): Observable<TurnError> {\n  return subject.pipe(\n    ofType<BroadcastPlayerTurnError>(MessageName.BROADCAST_PLAYER_TURN_ERROR),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastStartRound(subject: WebSocketSubject<Message>): Observable<StartRoundData> {\n  return subject.pipe(\n    ofType<BroadcastStartRound>(MessageName.BROADCAST_START_ROUND),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastEndRound(subject: WebSocketSubject<Message>): Observable<EndRoundData> {\n  return subject.pipe(\n    ofType<BroadcastEndRound>(MessageName.BROADCAST_END_ROUND),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastStartCycle(subject: WebSocketSubject<Message>): Observable<StartCycleData> {\n  return subject.pipe(\n    ofType<BroadcastStartCycle>(MessageName.BROADCAST_START_CYCLE),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastEndCycle(subject: WebSocketSubject<Message>): Observable<EndCycleData> {\n  return subject.pipe(\n    ofType<BroadcastEndCycle>(MessageName.BROADCAST_END_CYCLE),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastStartPlayerTurn(subject: WebSocketSubject<Message>): Observable<PlayerId> {\n  return subject.pipe(\n    ofType<BroadcastStartPlayerTurn>(MessageName.BROADCAST_START_PLAYER_TURN),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastEndGame(subject: WebSocketSubject<Message>): Observable<EndGameData> {\n  return subject.pipe(\n    ofType<BroadcastEndGame>(MessageName.BROADCAST_END_GAME),\n    map((value) => value.data),\n  );\n}\n\nfunction broadcastGameError(subject: WebSocketSubject<Message>): Observable<Error> {\n  return subject.pipe(\n    ofType<BroadcastGameError>(MessageName.BROADCAST_GAME_ERROR),\n    map((value) => value.data),\n  );\n}\n\nfunction availableCards(subject: WebSocketSubject<Message>): Observable<Card[]> {\n  return subject.pipe(\n    ofType<AvailableCards>(MessageName.AVAILABLE_CARDS),\n    map((value) => value.data),\n  );\n}\n\nexport default function create(subject: WebSocketSubject<Message>): ServerApi {\n  return {\n    startGame: startGame.bind(null, subject),\n    broadcastStartGame: broadcastStartGame.bind(null, subject),\n    dealtCards: dealtCards.bind(null, subject),\n    requestCards: requestCards.bind(null, subject),\n    playCards: playCards.bind(null, subject),\n    broadcastPlayerTurn: broadcastPlayerTurn.bind(null, subject),\n    broadcastPlayerTurnError: broadcastPlayerTurnError.bind(null, subject),\n    broadcastStartRound: broadcastStartRound.bind(null, subject),\n    broadcastEndRound: broadcastEndRound.bind(null, subject),\n    broadcastStartCycle: broadcastStartCycle.bind(null, subject),\n    broadcastEndCycle: broadcastEndCycle.bind(null, subject),\n    broadcastStartPlayerTurn: broadcastStartPlayerTurn.bind(null, subject),\n    broadcastEndGame: broadcastEndGame.bind(null, subject),\n    broadcastGameError: broadcastGameError.bind(null, subject),\n    availableCards: availableCards.bind(null, subject),\n  };\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { useEffect, useState } from 'react';\nimport { Message } from 'agurk-shared';\nimport { webSocket, WebSocketSubject } from 'rxjs/webSocket';\nimport logo from './logo.svg';\nimport './App.css';\nimport Game from './Game';\nimport createServerApi from './communication/serverApi';\n\nconst WS_SERVER_URI = 'ws://localhost:3001';\n\nexport default function App() {\n  const [subject] = useState<WebSocketSubject<Message>>(webSocket(WS_SERVER_URI));\n\n  useEffect(() => {\n    subject.subscribe();\n    return () => subject.complete();\n  }, [subject]);\n\n  const serverApi = createServerApi(subject);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n      </header>\n\n      <main>\n        <Game serverApi={serverApi} />\n      </main>\n    </div>\n  );\n}\n"],"sourceRoot":""}